{
  "hash": "02b1bf2a6420dde0672f270e2614de30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 9\"\ndescription: \"Generative Art\"\nauthor:\n  - name: Lily Cook\ndate: 06-02-2025\ncategories: [Advanced R] \nimage: ../../media/madras.jpg\ndraft: false \nexecute: \n  echo: true\n  warning: false\nformat: html\nembed-resources: true\neditor: source\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tibble)\nlibrary(ggforce)\nlibrary(deldir)\nlibrary(ggthemes)\nlibrary(tictoc)\nlibrary(ambient)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(sf)\n```\n:::\n\n\n\n\n## Midnight Stargazing\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generating random variables using various distributions\nw <- rpois(300, 70)\nx <- rgamma(300, 3)\ny <- rnorm(300, 50, 200)\nz <- rbinom(300, 200, 0.7)\na <- sample(c('a', 'b', 'c'), replace = T, size = 300)\n\ndata <- cbind(w, x, y, z, a) # combining into df\n\n\n# create gradient color pallete\npal <- colorRampPalette(c(\"lightgoldenrod1\",\"azure3\", \"slateblue\"))\n\nart_colors <- pal(n_distinct(w))\n\n#plot\n\nggplot(data, aes(x = y, y = z)) +\n  geom_point(aes(shape = a, color = w), show.legend = F, alpha = 0.9) + #add points\n  geom_line(aes(group = w, color = w), linetype = 3, show.legend = F, alpha = 0.3)+ # connect points\n  scale_shape_manual(values = c(\"a\" = 20, \"b\" = 8, \"c\" = 21)) + # change shapes of points\n  scale_color_manual(values = art_colors) + # change colors\n  coord_radial() + #circle\n  theme_void() + #remove everything\n  theme(panel.background = element_rect(fill = \"midnightblue\", color = \"midnightblue\")) # background color\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/piece 1-1.png){width=672}\n:::\n:::\n\n\n\n\n#### Description\n\nGazing at the midnight stars, your eyes drift between the celestial bodies. The stars seem to be randomly scattered across the sky.....\n\n#### Code choices\n\nBy adding `coord_radial()`, the art piece now has a circular shape. Setting the background fill and color gives the same midnight blue color as the backdrop of the piece. Adjusting the alpha in the `geoms` adjusts the opacity of the shapes on the plot. `scale_color_manual` allows me to choose a palette and `scale_shape_manual` allows me to choose the shapes the points will be. Lastly, using `theme_void` removes all titles, axis lines, etc. to give the appearance of art.\n\n## Central Coast Spring\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# defining palette that I want\nmy_pal <- c(\"#4A5d23\", \"#708238\", \"#568203\",\"#8A9A5B\", \"#6B8E23\", \"#A0522D\", \"#8B4513\", \"#7e481c\", \"goldenrod1\")\n\n\n\n# function to randomly select row from danielle\nchoose_rectangle <- function(blocks) {\n  sample(nrow(blocks), 1, prob = blocks$area)\n}\n\n# function to randomly set rectangle breaks from danielle\nchoose_break <- function(lower, upper) {\n  round((upper - lower) * runif(1))\n}\n\n# function to create tibble of rectangles from danielle\ncreate_rectangles <- function(left, right, bottom, top, value) {\n  tibble(\n    left = left,\n    right = right,\n    bottom = bottom,\n    top = top,\n    width = right - left,\n    height = top - bottom,\n    area = width * height,\n    value = value\n  )\n}\n\n# danielle function to split rectangle horizontally\nsplit_rectangle_x <- function(rectangle, new_value) {\n  with(rectangle, {\n    split <- choose_break(left, right)\n    new_left  <- c(left, left + split)\n    new_right <- c(left + split, right)\n    new_value <- c(value, new_value)\n    create_rectangles(new_left, new_right, bottom, top, new_value)\n  })\n}\n\n# danielle function to split rectangle vertically\nsplit_rectangle_y <- function(rectangle, new_value) {\n  with(rectangle, {\n    split <- choose_break(bottom, top)\n    new_bottom <- c(bottom, bottom + split)\n    new_top <- c(bottom + split, top)\n    new_value <- c(value, new_value)\n    create_rectangles(left, right, new_bottom, new_top, new_value)\n  })\n}\n\n# danielle function combining the two split functions\n\nsplit_rectangle <- function(rectangle, value) {\n  if(runif(1) < .5) {\n    return(split_rectangle_x(rectangle, value))\n  }\n  split_rectangle_y(rectangle, value)\n}\n\n# danielle function to randomly split rectangle\nsplit_block <- function(blocks, value) {\n  old <- choose_rectangle(blocks) \n  new <- split_rectangle(blocks[old, ], value)\n  bind_rows(blocks[-old, ], new)\n}\n\n\n# danielle function to repeatedly divide rectangles\n\nsubdivision <- function(ncol = 1000, \n                        nrow = 1000, \n                        nsplits = 50, \n                        seed = NULL) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  blocks <- create_rectangles(\n    left = 1, \n    right = ncol, \n    bottom = 1, \n    top = nrow, \n    value = 0\n  )\n  reduce(1:nsplits, split_block, .init = blocks)\n}\n\n# danielle function to fracture/ fill square basicall the start of the mosaic\nfill_rectangle <- function(left, right, bottom, top, width, \n                           height, area, value, nshades = 100) {\n  \n  set.seed(value)\n  fractals <- list(billow, fbm, ridged)\n  generators <- list(gen_simplex, gen_perlin, gen_worley)\n  \n  expand_grid(\n    x = left:right, \n    y = bottom:top, \n  ) |>\n    mutate(\n      fill = 10 * value + fracture(\n        x = x * sample(-3:3, 1),\n        y = y * sample(-3:3, 1),\n        noise = sample(generators, 1)[[1]],\n        fractal = sample(fractals, 1)[[1]],\n        octaves = sample(10, 1),\n        frequency = sample(10, 1) / 20,\n        value = \"distance2\"\n      ) |>\n        normalise(to = c(1, nshades)) |> \n        round()\n    )\n}\n\n# danielle function to plot squares\ndraw_mosaic <- function(dat, palette) {\n  background <- sample(palette[1:5], 1) #edited\n  dat |>\n    ggplot(aes(x, y, fill = fill)) +\n    geom_tile(show.legend = FALSE, colour = background, size = .2) +\n    scale_size_identity() +\n    scale_colour_gradientn(colours = palette) +\n    scale_fill_gradientn(colours = palette) +\n    scale_x_continuous(expand = expansion(add = 5)) +\n    scale_y_continuous(expand = expansion(add = 5)) +\n    coord_equal() +\n    theme_void() +\n    theme(plot.background = element_rect(fill = background)) \n}\n\n\n# danielle function bringing it all together - edited palette\nmosaica <- function(ncol = 60, \n                    nrow = 60, \n                    nsplits = 30, \n                    seed = NULL) {\n  \n  subdivision(ncol, nrow, nsplits, seed) |>\n    pmap_dfr(fill_rectangle) |> \n    slice_sample(prop = .995) |>\n    filter(!is.na(fill)) |>\n    draw_mosaic(palette = my_pal) #added my palette here for more control\n}\n\n\n\nmosaica(ncol = 200, nrow = 150, nsplits = 3000, seed = 541)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/piece 2-1.png){width=672}\n:::\n:::\n\n\n\n\n#### Description\n\nSpring has arrived in the central coast of California. Green grass spreads across the hills dotted with yellow blooms.\n\n#### Code Choices\n\nI decided to choose my own palette instead of allowing for a random palette as the shapes reminded me of fields. This was also more fun for me. I also edited the `background` call in the `draw_mosaic` function to select a green from the palette rather than the browns or yellow. In the function call to `mosaica`, `ncol` is set to 200, meaning the art will be 200 \"pixels\" wide, and `nrow` is set to 150, meaning the art will be 150 \"pixels\" tall. The `nsplits` argument is set to 3000, meaning the art will be divided into 300 \"rectangles\", though the nature of the mosaic allows for the shapes to be non-rectangular (or at least not perfectly rectangular). This is a large number of splits and allows for more \"detail\" in the drawing\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}